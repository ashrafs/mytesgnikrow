#include <cephesd.h>
#include "cblas_ext.h"
#include "argsort.h"
#include "SdGaussian1D.h"
#include "sdcpp.h"


#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;




void project_SR_with_stats( int *ofs, int *size, double *stats,
    int nind, int *ind, double *A,
    double *stats1d )
{
    double *ssta, *ssta2, *dsta, val;
    int i, j, k;

    // project
    for( ssta = stats, dsta = stats1d, k = 0; k < 2; ++k, ssta += /*ofs[3]*/ofs[2]+size[2], dsta += 3 )
    {
        // total weights
        dsta[0] = ssta[0];

        // mean
        dsta[1] = 0;
        ssta2 = ssta + 1;
        for( i = 0; i < nind; ++i ) dsta[1] += A[i] * ssta2[ind[i]];

        // standard deviation
        dsta[2] = 0;
        for( i = 0; i < nind; ++i )
        {
            ssta2 = ssta + ofs[2] + ind[i]*size[1];
            val = 0;
            for( j = 0; j < nind; ++j ) val += A[j] * ssta2[ind[j]];
            dsta[2] += A[i] * val;
        }
        dsta[2] = sqrt(dsta[2]); // convert from variance to standard deviation
    }
}



// use stack allocation for faster speed, but with limitation
#define NRECTS 10
#define NPOP 100
#define NVEC (NRECTS * 5)
#define NPOS (NRECTS * 4)


// Documentation of this class here
class SdSRSolver
{
public:
    double *dstats;

    int nvec, plen, npop, nrects;
    double eps;
    int scal, CR;

    int tvec[NVEC], pop[NVEC*NPOP], bid;
    double tval, bval, value[NPOP];

    double A[NPOS], A2[NPOS];
    int len, nind, ind[NPOS], ind2[NPOS], id[NPOS];
//    int ofs[4];
    int *ofs, *size;

    int criterion;
    double param1;

    double stats[6], err_res[2];

    int ngenome, nvgenome, ngen;
public:
    void randvec(int *ddst)
    {
        for( int i = 0; i < nrects; ++i, ddst += 5 )
        {
            ddst[0] = irand(21) - 10; // a_i = [-10,10]
            ddst[1] = irand(plen-1); // x_i = [0,plen-2]
            ddst[2] = irand(plen-1); // y_i = [0,plen-2]
            ddst[3] = 1+irand(plen-1); // w_i = [1,plen-1]
            ddst[4] = 1+irand(plen-1); // h_i = [1,plen-1]
        }
    }


    bool refine(int *ddst)
    {
        bool got_pos = false, got_neg = false;
        for( int i = 0; i < nrects; ++i, ddst += 5 )
        {
            if(ddst[0] < 0) got_neg = true;
            if(ddst[0] > 0) got_pos = true;

            if(ddst[1] < 0) ddst[1] = 0;
            if(ddst[1] >= plen-1) ddst[1] = plen-2;

            if(ddst[2] < 0) ddst[2] = 0;
            if(ddst[2] >= plen-1) ddst[2] = plen-2;

            if(ddst[3] < 1) ddst[3] = 1;
            if(ddst[1]+ddst[3] >= plen) ddst[3] = plen-1-ddst[1];

            if(ddst[4] < 1) ddst[4] = 1;
            if(ddst[2]+ddst[4] >= plen) ddst[4] = plen-1-ddst[2];
        }
        return got_pos && got_neg;
    }


    void generate(int n)
    {
        int i, *d0, *d1, *d2, *d3;
//        int j, j1, j2;

        do
        {
            ngenome++;
            d0 = pop + n*nvec;
//            d1 = pop + irand(npop)*nvec;
            d1 = pop + bid*nvec;
            d2 = pop + irand(npop)*nvec;
            d3 = pop + irand(npop)*nvec;
//            j2 = 0;

//            for( i = 0; i < nrects; ++i )
//            {
//                j1 = j2;
//                j2 += 5;
//
//                if(irand(32768) < CR) for( j = j1; j < j2; ++j ) tvec[j] = d0[j];
//                else for( j = j1; j < j2; ++j ) tvec[j] = d1[j] + ((scal*(d2[j]-d3[j])) >> 15);
//            }
//

            for( i = 0; i < nvec; ++i )
                tvec[i] = (irand(32768) < CR)? d0[i]: d1[i] + ((scal*(d2[i]-d3[i])) >> 15);
        } while(!refine(tvec));
        nvgenome++;
    }

    bool is_converged()
    {
        double result[2] = {0,0};
        minmax<double>(npop,value,result);
        return (result[1] - result[0]) <= eps;
    }

    // convert from genome to (A,ind)
    void to_index(int *ddest)
    {
        double spos, sneg, factor;
        int *ddst;
        int i, j, k1, k2;

        // find sum_pos and sum_neg
        k1 = k2 = 0;
        for( ddst = ddest, i = 0; i < nrects; ++i, ddst += 5 )
        {
            j = ddst[0]*ddst[3]*ddst[4];
            if(ddst[0] >= 0) k1 += j;
            else k2 -= j;
        }

        // rest assured by refine() that k1 and k2 are both != 0
        spos = 1.0 / k1;
        sneg = 1.0 / k2;

        j = 0;
        for( ddst = ddest, i = 0; i < nrects; ++i, ddst += 5 )
        {
            if(ddst[0] > 0) factor = spos;
            else if(ddst[0] < 0) factor = sneg;
            else continue;

            k1 = ddst[2] * plen + ddst[1]; // (x,y)
            k2 = k1 + ddst[4] * plen; // (x,y+h)

            A2[j] = factor;
            ind2[j++] = k1;

            A2[j] = -factor;
            ind2[j++] = k2;

            A2[j] = -factor;
            ind2[j++] = k1+ddst[3];

            A2[j] = factor;
            ind2[j++] = k2+ddst[3];
        }

        // sort them
        argsort<int>(j,ind2,id);

        // combine and remove zero elements
        k1 = 0;
        ind[0] = ind2[id[0]];
        A[0] = A2[id[0]];
        for( k2 = 1; k2 < j; ++k2 )
            if(ind[k1] == ind2[id[k2]]) A[k1] += A2[id[k2]];
            else
            {
                if(fabs(A[k1]) > eps) ++k1;
                ind[k1] = ind2[id[k2]];
                A[k1] = A2[id[k2]];
            }
        nind = k1+1;


//        // build the index-coefficient table
//        for( i = 0; i < len; ++i ) A[i] = 0;
//        for( ddst = ddest, i = 0; i < nrects; ++i, ddst += 5 )
//        {
//            if(ddst[0] > 0) factor = spos;
//            else if(ddst[0] < 0) factor = sneg;
//            else continue;
//
//            k1 = ddst[2] * plen + ddst[1]; // (x,y)
//            k2 = k1 + ddst[4] * plen; // (x,y+h)
//            j = ddst[3]; // w
//
//            A[k1] += factor;
//            A[k2] -= factor;
//            A[k1+j] -= factor;
//            A[k2+j] += factor;
//        }
//
//        // remove zero elements
//        nind = 0;
//        for( i = 0; i < len; ++i ) if(fabs(A[i]) > eps)
//        {
//            A[nind] = A[i];
//            ind[nind++] = i;
//        }
    }

    void project()
    {
        project_SR_with_stats(ofs, size, dstats, nind, ind, A, stats);

        // need to invert the direction
        if(stats[1] > stats[4])
        {
            stats[1] = -stats[1];
            stats[4] = -stats[4];
            for( int i = 0; i < nind; ++i ) A[i] = -A[i];
        }
    }


    double get_value(int *ddst)
    {
        to_index(ddst);
        project();
        sdGTSolve(criterion,param1,stats,err_res);
        return err_res[1]; // return the resulting error, ignoring the threshold for now
    }



    SdSRSolver(
        int nrects,
        int criterion, double param1,
        int patch_len, int *ofs, int *size, double *dstats,
        int npop = 100,
        double crossover_rate = 0.8, double scale = -1, double eps = 1E-6)
    {
        int *ddst;
        int i;

        this->nrects = nrects;

        this->criterion = criterion;
        this->param1 = param1;

        this->plen = patch_len;
        this->dstats = dstats;

        len = patch_len * patch_len;

        this->ofs = ofs;
        this->size = size;
//        ofs[0] = 0;
//        ofs[1] = 1;
//        ofs[2] = 1 + len;
//        ofs[3] = ofs[2] + len*len;

        this->npop = npop;
        nvec = nrects * 5; // each rectangle requires 5 numbers

        for( i = 0, ddst = pop; i < npop; ++i, ddst += nvec )
        {
            do randvec(ddst);
            while(!refine(ddst));
            value[i] = get_value(ddst);
            if(!i || value[i] < bval)
            {
                bval = value[i];
                bid = i;
            }
        }

        this->CR = (int)floor(crossover_rate*32768);
        this->eps = eps;
        if(scale < 0)
        {
            double result[2];
            minmax<double>(npop,value,result);
            scale = fabs(result[0]/result[1]);
            if(1 < scale) scale = 1/scale;
            if(scale < 0.3) scale = 0.3;
        }
        this->scal = (int)floor(scale * 32768);

        ngenome = nvgenome = ngen = 0;
    }

    bool solve(double nseconds = 5)
    {
        clock_t startclock = clock();
        clock_t duration = nseconds * CLOCKS_PER_SEC;
        while(clock() < startclock + duration)
        {
            ngen++;
            for( int i = 0; i < npop; ++i )
            {
                generate(i);
                tval = get_value(tvec);
                if(tval < value[i])
                {
                    value[i] = tval;
                    memcpy( (void *)(pop+i*nvec), (const void *)tvec, nvec*sizeof(int) );
                    if(tval < bval)
                    {
                        bval = tval;
                        bid = i;
//                        cout << "best=" << bval << endl;
                    }
                }
            }

            if(is_converged()) return true;
        }
        return false;
    }
};



void sdBestSR( int len, int *ofs, int *size, double *stats,
    int criterion, double param1,
    int nrects, double nseconds,
    int *out_ints, double *out_doubles )
{
    SdSRSolver srs(nrects, criterion, param1, len, ofs, size, stats );
    srs.solve(nseconds);
    // Results are stored in both out_ints (for integers) and out_doubles (for doubles)
    // Including:
    //      out_ints[0]: the number of non-zero elements in the SR feature (<= 4*nrects)
    //      out_ints[1]: the number of generations used
    //      out_ints[2]: the number of genomes used
    //      out_ints[3]: the number of valid genomes used
    //      out_ints[4] and the rest: indices to each non-zero elements, ascending order
    //      out_doubles[0]: threshold value of the best genome
    //      out_doubles[1]: 'error' of the best genome
    //      out_doubles[2] and the rest: coefficients of each non-zero elements
    srs.get_value(srs.pop + srs.bid * srs.nvec);
    out_ints[0] = srs.nind;
    out_ints[1] = srs.ngen;
    out_ints[2] = srs.ngenome;
    out_ints[3] = srs.nvgenome;
    out_doubles[0] = srs.err_res[0];
    out_doubles[1] = srs.err_res[1];
    for( int i = 0; i < out_ints[0]; ++i )
    {
        out_ints[4+i] = srs.ind[i];
        out_doubles[2+i] = srs.A[i];
    }
}




//
//// how to produce the following content for 'stats':
//// Use python with sdpy:
//// from sdpy.cs import cv
//// from numpy.random import random
//// a = (random((2,10,2,2))*100).astype('uint8') # 2 classes, each with 10 2x2 patch examples
//// from sdpy.cs.ml.cla import WeightedCDataset
//// cd = WeightedCDataset(a) # store as a dataset
//// stats = cv.compute_Stats2_integral(cd,False) # build their Stats2
//// stats.A
//double stats[2*(1+9+81)] = {
//        20.    ,    52.55  ,   104.55  ,   157.25  ,    97.05  ,
//          192.55  ,   296.15  ,   146.4   ,   293.9   ,   441.85  ,
//          960.7475,   312.9475,   209.9625,   957.8225,   145.7975,
//         -151.5325,   971.93  ,   213.255 ,  -254.8175,   312.9475,
//          769.6475,   706.9625,   347.6725,  1013.3975,   996.7175,
//          770.23  ,  1598.655 ,  1372.3825,   209.9625,   706.9625,
//         1341.8875,   254.9875,  1044.6625,  1679.0125,   693.2   ,
//         1715.275 ,  2093.1875,   957.8225,   347.6725,   254.9875,
//         1766.8475,   894.6725,   718.2925,  1955.63  ,  1477.855 ,
//         1021.1075,   145.7975,  1013.3975,  1044.6625,   894.6725,
//         2575.0475,  2558.4675,  1318.78  ,  3330.605 ,  2941.8325,
//         -151.5325,   996.7175,  1679.0125,   718.2925,  2558.4675,
//         3955.9275,  1116.49  ,  3637.815 ,  4591.8725,   971.93  ,
//          770.23  ,   693.2   ,  1955.63  ,  1318.78  ,  1116.49  ,
//         3327.44  ,  3014.39  ,  2556.16  ,   213.255 ,  1598.655 ,
//         1715.275 ,  1477.855 ,  3330.605 ,  3637.815 ,  3014.39  ,
//         6088.59  ,  5880.835 ,  -254.8175,  1372.3825,  2093.1875,
//         1021.1075,  2941.8325,  4591.8725,  2556.16  ,  5880.835 ,
//         7581.8275,
//        20.    ,    49.9   ,   105.8   ,   158.7   ,    88.35  ,
//          192.55  ,   295.45  ,   127.8   ,   278.15  ,   424.8   ,
//          591.29  ,   702.58  ,   628.72  ,   645.135 ,   783.905 ,
//          628.695 ,   739.03  ,   827.215 ,   777.28  ,   702.58  ,
//         1701.76  ,  1416.29  ,   545.67  ,  1756.21  ,  1426.14  ,
//          791.56  ,  1739.73  ,  1498.56  ,   628.72  ,  1416.29  ,
//         2071.31  ,   269.655 ,  1307.615 ,  1835.935 ,   742.34  ,
//         1439.395 ,  2064.84  ,   645.135 ,   545.67  ,   269.655 ,
//         1761.4275,  1907.4075,  1530.9925,  1828.22  ,  2182.5475,
//         2023.72  ,   783.905 ,  1756.21  ,  1307.615 ,  1907.4075,
//         4080.7475,  3561.7525,  2160.56  ,  4429.1175,  4163.26  ,
//          628.695 ,  1426.14  ,  1835.935 ,  1530.9925,  3561.7525,
//         4255.8475,  2105.34  ,  4040.1825,  5052.99  ,   739.03  ,
//          791.56  ,   742.34  ,  1828.22  ,  2160.56  ,  2105.34  ,
//         2517.46  ,  3020.18  ,  3445.31  ,   827.215 ,  1739.73  ,
//         1439.395 ,  2182.5475,  4429.1175,  4040.1825,  3020.18  ,
//         6173.7275,  6128.53  ,   777.28  ,  1498.56  ,  2064.84  ,
//         2023.72  ,  4163.26  ,  5052.99  ,  3445.31  ,  6128.53  ,
//         8091.66
//};
//
//double stats2[2*(1+16+256)] = {
//        30.        ,     54.93333333,    109.8       ,    168.16666667,
//           218.9       ,    106.23333333,    212.13333333,    319.93333333,
//           424.8       ,    155.93333333,    310.66666667,    472.        ,
//           630.4       ,    199.16666667,    407.63333333,    628.43333333,
//           831.3       ,    875.06222222,   1051.15333333,   1089.31111111,
//          1340.59333333,    949.51555556,   1023.40888889,    940.56222222,
//          1218.42      ,    935.92888889,   1012.21111111,   1138.4       ,
//          1437.39333333,    772.97777778,    935.47555556,   1115.46222222,
//          1534.48666667,   1051.15333333,   2222.76      ,   2240.1       ,
//          2365.54666667,   1200.41333333,   2499.62666667,   2138.48666667,
//          2431.99333333,   1078.78666667,   2697.83333333,   2418.23333333,
//          2750.74666667,    854.13333333,   2396.76      ,   2076.02      ,
//          2534.59333333,   1089.31111111,   2240.1       ,   2976.47222222,
//          3042.85      ,   1249.19444444,   2757.87777778,   3472.64444444,
//          3679.83333333,   1186.51111111,   2958.72222222,   3709.63333333,
//          4027.56666667,   1148.07222222,   2879.02777778,   3777.79444444,
//          4299.71666667,   1340.59333333,   2365.54666667,   3042.85      ,
//          3949.42333333,   1586.15666667,   3114.64666667,   3441.52666667,
//          4503.24666667,   1651.69333333,   3492.8       ,   3916.9       ,
//          5030.07333333,   1440.88333333,   3520.69666667,   4135.37666667,
//          5442.46333333,    949.51555556,   1200.41333333,   1249.19444444,
//          1586.15666667,   1706.71222222,   1819.76888889,   1533.88222222,
//          1949.34666667,   1685.11555556,   1970.71111111,   1941.56666667,
//          2307.47333333,   1588.89444444,   1825.55222222,   1965.29888889,
//          2436.39666667,   1023.40888889,   2499.62666667,   2757.87777778,
//          3114.64666667,   1819.76888889,   4264.64888889,   3869.00888889,
//          4408.32666667,   1850.54222222,   5035.21111111,   4647.53333333,
//          5213.21333333,   1962.24444444,   4824.91555556,   4780.80888889,
//          5311.42666667,    940.56222222,   2138.48666667,   3472.64444444,
//          3441.52666667,   1533.88222222,   3869.00888889,   5760.46222222,
//          5758.22      ,   1623.79555556,   4502.01111111,   6246.16666667,
//          6318.36      ,   2158.74444444,   4738.94222222,   7095.42888889,
//          7153.95333333,   1218.42      ,   2431.99333333,   3679.83333333,
//          4503.24666667,   1949.34666667,   4408.32666667,   5758.22      ,
//          7145.69333333,   2250.32      ,   5189.        ,   6727.16666667,
//          8271.38      ,   2585.26666667,   5216.22666667,   7681.78666667,
//          9138.36      ,    935.92888889,   1078.78666667,   1186.51111111,
//          1651.69333333,   1685.11555556,   1850.54222222,   1623.79555556,
//          2250.32      ,   2316.39555556,   2660.04444444,   3028.93333333,
//          3417.09333333,   2324.91111111,   2401.20888889,   3021.36222222,
//          3531.92      ,   1012.21111111,   2697.83333333,   2958.72222222,
//          3492.8       ,   1970.71111111,   5035.21111111,   4502.01111111,
//          5189.        ,   2660.04444444,   7385.02222222,   7120.16666667,
//          7554.16666667,   2807.12222222,   7036.47777778,   7114.17777778,
//          7389.9       ,   1138.4       ,   2418.23333333,   3709.63333333,
//          3916.9       ,   1941.56666667,   4647.53333333,   6246.16666667,
//          6727.16666667,   3028.93333333,   7120.16666667,   9803.46666667,
//         10173.1       ,   3674.53333333,   6932.6       ,  10363.76666667,
//         10841.56666667,   1437.39333333,   2750.74666667,   4027.56666667,
//          5030.07333333,   2307.47333333,   5213.21333333,   6318.36      ,
//          8271.38      ,   3417.09333333,   7554.16666667,  10173.1       ,
//         12843.90666667,   4067.06666667,   7508.98      ,  11303.86      ,
//         13770.01333333,    772.97777778,    854.13333333,   1148.07222222,
//          1440.88333333,   1588.89444444,   1962.24444444,   2158.74444444,
//          2585.26666667,   2324.91111111,   2807.12222222,   3674.53333333,
//          4067.06666667,   3267.40555556,   3318.72777778,   4602.42777778,
//          4931.28333333,    935.47555556,   2396.76      ,   2879.02777778,
//          3520.69666667,   1825.55222222,   4824.91555556,   4738.94222222,
//          5216.22666667,   2401.20888889,   7036.47777778,   6932.6       ,
//          7508.98      ,   3318.72777778,   8206.29888889,   8566.45888889,
//          8768.71      ,   1115.46222222,   2076.02      ,   3777.79444444,
//          4135.37666667,   1965.29888889,   4780.80888889,   7095.42888889,
//          7681.78666667,   3021.36222222,   7114.17777778,  10363.76666667,
//         11303.86      ,   4602.42777778,   8566.45888889,  13482.17888889,
//         14214.70333333,   1534.48666667,   2534.59333333,   4299.71666667,
//          5442.46333333,   2436.39666667,   5311.42666667,   7153.95333333,
//          9138.36      ,   3531.92      ,   7389.9       ,  10841.56666667,
//         13770.01333333,   4931.28333333,   8768.71      ,  14214.70333333,
//         17330.61      ,
//        30.        ,     47.36666667,     94.16666667,    131.03333333,
//           173.73333333,     94.1       ,    192.86666667,    283.86666667,
//           376.1       ,    146.26666667,    289.06666667,    427.53333333,
//           570.26666667,    196.26666667,    388.13333333,    576.23333333,
//           766.33333333,    899.43222222,    789.97222222,    849.92111111,
//           856.56444444,   1187.06333333,   1015.61555556,   1217.04888889,
//          1046.06333333,   1198.90222222,   1057.44222222,   1253.30444444,
//           925.76888889,   1066.80222222,    866.91777778,    846.98111111,
//           381.77777778,    789.97222222,   1582.80555556,   1310.92777778,
//          1115.64444444,    967.28333333,   1651.35555556,   1619.18888889,
//          1393.21666667,    800.35555556,   1578.25555556,   1733.31111111,
//          1202.68888889,    752.18888889,   1727.67777778,   1557.59444444,
//           990.64444444,    849.92111111,   1310.92777778,   1857.63222222,
//          1709.20888889,   1145.86333333,   1714.97111111,   2506.53777778,
//          2522.03      ,   1135.95777778,   1625.93111111,   2668.58222222,
//          2391.79111111,   1094.39111111,   1581.72888889,   2397.52555556,
//          2221.72222222,    856.56444444,   1115.64444444,   1709.20888889,
//          2306.46222222,   1406.46      ,   1794.39777778,   2658.29777778,
//          3424.39333333,   1219.83777778,   1598.68444444,   2598.94222222,
//          3247.83777778,   1321.57111111,   1732.66888889,   2196.29555556,
//          3124.72222222,   1187.06333333,    967.28333333,   1145.86333333,
//          1406.46      ,   2447.09      ,   2126.51333333,   2965.58      ,
//          3042.95666667,   2540.54      ,   2039.16      ,   2689.41333333,
//          2497.67333333,   2684.40666667,   2050.98666667,   2519.11      ,
//          2148.26666667,   1015.61555556,   1651.35555556,   1714.97111111,
//          1794.39777778,   2126.51333333,   3307.84888889,   4089.28222222,
//          4045.68      ,   1766.03555556,   2601.17555556,   3404.13777778,
//          2849.26888889,   1991.90222222,   2776.18444444,   3342.93111111,
//          2783.34444444,   1217.04888889,   1619.18888889,   2506.53777778,
//          2658.29777778,   2965.58      ,   4089.28222222,   6549.64888889,
//          6573.58      ,   2837.33555556,   3147.87555556,   5619.03777778,
//          5281.63555556,   3174.93555556,   3246.35111111,   5611.89777778,
//          5356.74444444,   1046.06333333,   1393.21666667,   2522.03      ,
//          3424.39333333,   3042.95666667,   4045.68      ,   6573.58      ,
//          8027.75666667,   2839.94      ,   3198.49333333,   5817.28      ,
//          6979.77333333,   3294.77333333,   3625.38666667,   5902.71      ,
//          7405.        ,   1198.90222222,    800.35555556,   1135.95777778,
//          1219.83777778,   2540.54      ,   1766.03555556,   2837.33555556,
//          2839.94      ,   3487.19555556,   2521.14888889,   3286.69111111,
//          3040.72888889,   3612.46222222,   2525.59777778,   3132.20444444,
//          2794.34444444,   1057.44222222,   1578.25555556,   1625.93111111,
//          1598.68444444,   2039.16      ,   2601.17555556,   3147.87555556,
//          3198.49333333,   2521.14888889,   3481.79555556,   3929.86444444,
//          3415.24888889,   2607.61555556,   3526.92444444,   3534.61777778,
//          2999.41111111,   1253.30444444,   1733.31111111,   2668.58222222,
//          2598.94222222,   2689.41333333,   3404.13777778,   5619.03777778,
//          5817.28      ,   3286.69111111,   3929.86444444,   7094.78222222,
//          6900.19111111,   3368.19111111,   3920.32888889,   6716.17555556,
//          6515.55555556,    925.76888889,   1202.68888889,   2391.79111111,
//          3247.83777778,   2497.67333333,   2849.26888889,   5281.63555556,
//          6979.77333333,   3040.72888889,   3415.24888889,   6900.19111111,
//          9098.52888889,   3318.72888889,   3863.23111111,   6826.13777778,
//          9366.14444444,   1066.80222222,    752.18888889,   1094.39111111,
//          1321.57111111,   2684.40666667,   1991.90222222,   3174.93555556,
//          3294.77333333,   3612.46222222,   2607.61555556,   3368.19111111,
//          3318.72888889,   4674.39555556,   3232.53111111,   3921.57111111,
//          3840.51111111,    866.91777778,   1727.67777778,   1581.72888889,
//          1732.66888889,   2050.98666667,   2776.18444444,   3246.35111111,
//          3625.38666667,   2525.59777778,   3526.92444444,   3920.32888889,
//          3863.23111111,   3232.53111111,   4698.98222222,   4604.10222222,
//          4624.22222222,    846.98111111,   1557.59444444,   2397.52555556,
//          2196.29555556,   2519.11      ,   3342.93111111,   5611.89777778,
//          5902.71      ,   3132.20444444,   3534.61777778,   6716.17555556,
//          6826.13777778,   3921.57111111,   4604.10222222,   8211.57888889,
//          8146.25555556,    381.77777778,    990.64444444,   2221.72222222,
//          3124.72222222,   2148.26666667,   2783.34444444,   5356.74444444,
//          7405.        ,   2794.34444444,   2999.41111111,   6515.55555556,
//          9366.14444444,   3840.51111111,   4624.22222222,   8146.25555556,
//         12038.22222222
//};
//
//
//int test_sr(int argc, char *argv[])
//{
//    init_sdcpp();
//    cout.precision(10);
//    SdSRSolver srs(8,0, 10, 4, stats2);
//    if(srs.solve(10)) cout << "optimal lah" << endl;
//
//    cout << "There were " << srs.ngen << " generations with " <<
//        srs.ngenome << " genomes of which " << srs.nvgenome << " are valid." << endl;
//
//    cout << "The best genome scored " << srs.bval << endl;
//
//    return 0;
//}
//

